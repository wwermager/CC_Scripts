local function benchmark(start_time)
    return elapsed_time = os.clock() - start_time
    -- print(string.format("elapsed time: %.2fs\tbarrels opened: %d\tbarrels/sec: %.2fbps\n", elapsed_time, barrels_opened, barrels_opened/elapsed_time)) 
end
local function place_new()
    turtle.select(1)
    assert(turtle.place(), "Unable to place new barrel.")
    -- TODO optimize; Instead of moving barrel to storage every iteration, move only if 
    turtle.select(2)
    assert(turtle.drop(),"Unable to drop old barrel in new barrel.")
end

local hasBack, hasLeft, hasRight, hasUp, hasDown = false, false, false, false, false

-- Last exit before breaking barrel but after pulling mystery barrel
if peripheral.isPresent("front") and turtle.getItemDetail(1) then

    print("Resuming operation: barrel already processed, deploying a new one.")
    assert(turtle.dig(), "Unable to break barrel in front.") -- barrel dug will end up in second slot
    place_new()

-- Last exited after breaking barrel but before placing the new one
elseif not peripheral.isPresent("front") and turtle.getItemDetail(1) then
    
    print("Resuming operation: deploying a new barrel.")
    place_new()

else
    print("Resuming operation: existing barrel has inventory to be processed.")
end


local front = peripheral.wrap("front")

local back = peripheral.wrap("back")
if not (back == nil) then hasBack = true end

local left = peripheral.wrap("left")
if not (left == nil) then hasLeft = true end

local right = peripheral.wrap("right")
if not (right == nil) then hasRight = true end

local up = peripheral.wrap("top")
if not (up == nil) then hasUp = true end

local down = peripheral.wrap("bottom")
if not (down == nil) then hasDown = true end

assert(hasBack or hasLeft or hasRight or hasUp or hasDown, "At least one storage item (i.e. chest, drawer, barrel, etc.) must be placed directly to the left, right, back, top or bottom of the turtle.")

local barrels_opened = 0
local PUZZLE_NAME = "Test of Patience"
local PROCESS_START = os.clock()

while true do

    local barrel_items = front.list()
    local total_item_count = 0
    local deposited_count = 0

    local start_time = os.clock()
    for slot, item_info in pairs(barrel_items) do

        local item_name = item_info.name

        -- The mystery box (barrel) contains nbt data, while standard MC barrels do not
        -- Leave new mystery box in current barrel and remove only after removing all other items
        -- Additionally, check for the original mystery barrel name as it retains its nbt data after placing/breaking
        --  unlike its nested counterparts
        if not (item_name == "minecraft:barrel" and front.getItemDetail(slot).nbt) 
            or front.getItemDetail(slot).displayName == PUZZLE_NAME then

            total_item_count = total_item_count + item_info.count
            -- pushItems(String toName, Number fromSlot) returns count of deposited items
            
            if hasUp then
                deposited_count = deposited_count + front.pushItems(peripheral.getName(up),slot)
            end
            if hasRight then
                deposited_count = deposited_count + front.pushItems(peripheral.getName(right),slot)
            end
            if hasDown then
                deposited_count = deposited_count + front.pushItems(peripheral.getName(down),slot)
            end
            if hasLeft then
                deposited_count = deposited_count + front.pushItems(peripheral.getName(left),slot)
            end
            if hasBack then
                deposited_count = deposited_count + front.pushItems(peripheral.getName(back),slot)
            end
        
        end
    
    end
    print(string.format("processing of barrel took %.2f seconds\n",benchmark(start_time)))

    assert(total_item_count == deposited_count, "Unable to deposit items into attached storage.")
    barrels_opened = barrels_opened + 1
    -- print("Processed barrel " .. barrels_opened .. ".") 

    -- Only a single barrel remainins in the inventory, get it and break (dig) the placed barrel
    turtle.select(1)
    -- assert(turtle.suck(), "Unable to pull a new barrel from front. Perhaps the end was reached?")
    if not turtle.suck() then
        print(string.format("elapsed time: %.2fs\tbarrels opened: %d\n", benchmark(PROCESS_START), barrels_opened)) 
        error("Unable to pull a new barrel from front. Perhaps the end was reached?")
    end
    assert(turtle.dig(), "Unable to break barrel in front.")

    start_time = os.clock()
    place_new()
    print(string.format("place_new() took %.2f seconds\n",benchmark(start_time)))
end